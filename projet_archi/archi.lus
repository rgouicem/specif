const NPROCS: int=3;
const MEMSIZE: int = 2;
const WORDSIZE: int = 1;

-- wires definition
type b_wires = bool ^ 4;
const AD: int=0;
const CTRL: int=1;   -- true = write; false = read
const VALID: int=2;
const DT: int=3;

-- target IDs
const NONE: int = 0;
const MEM:  int = 1;
const CPU1: int = 2;
const CPU2: int = 3;
const CPU3: int = 4;

node memory (arb_gnt: int; b_out: b_wires) returns (b_in_mem: b_wires; b_req: bool; mem: bool ^ (MEMSIZE*WORDSIZE));
--var mem: bool ^ (MEMSIZE*WORDSIZE);
let
  mem = [0, 0]->(if b_out[VALID] and b_out[CTRL] then (if not b_out[AD] then [b_out[DT], pre mem[1]] else [pre mem[0], b_out[DT]]) else pre mem);
  b_in_mem = [0, 0, 0, 0]->(if b_out[VALID] then (if b_out[AD] then [0, 0, true, mem[1]] else [0, 0, true, mem[0]]) else [0, 0, false, 0]);
  b_req = false->(if b_out[VALID] and not b_out[CTRL] then true else false);
tel

node proc (op, valid, gel: bool; val: bool ^ WORDSIZE; ad: bool) returns (op_out, valid_out: bool; val_out: bool ^ WORDSIZE; ad_out: bool);
let
  op_out = op;
  valid_out = valid and not gel;
  val_out = val;
  ad_out = ad;
tel

node bcu (req: bool ^ (NPROCS+1)) returns (arb_gnt: int);
  --var last: int;
let
  --  last = CPU1->(if pre arb_gnt >= CPU1 then pre arb_gnt else pre last);
  --  arb_gnt = NONE->(if req[MEM-1] then MEM
  --                   else if req[last%NPROCS+1] then last%NPROCS+1
  --                        else if req[(last+1)%NPROCS+1] then (last+1)%NPROCS+1
  --                             else if req[(last+2)%NPROCS+1] then (last+2)%NPROCS+1
  --                                  else NONE);
  arb_gnt = NONE->(if req[MEM-1] then MEM
                   else if req[CPU1-1] then CPU1
                        else if req[CPU2-1] then CPU2
                             else if req[CPU3-1] then CPU3
                                  else NONE);
tel

node bus (b_in: bool ^ (4*(NPROCS+1)); arb_gnt: int) returns (b_out: b_wires);
let
  b_out = [0, 0, false, 0]->(if arb_gnt = MEM then [b_in[AD], b_in[CTRL], b_in[VALID], b_in[DT]]
                             else if arb_gnt = CPU1 then [b_in[4+AD], b_in[4+CTRL], b_in[4+VALID], b_in[4+DT]]
                                  else if arb_gnt = CPU2 then [b_in[8+AD], b_in[8+CTRL], b_in[8+VALID], b_in[8+DT]]
                                       else if arb_gnt = CPU3 then [b_in[12+AD], b_in[12+CTRL], b_in[12+VALID], b_in[12+DT]]
                                            else [0, 0, false, 0]);
tel

node cache (op, valid: bool; gnt: int; val: bool ^ WORDSIZE; ad: bool; b_out: b_wires) returns (gel, b_req: bool; b_in: b_wires; val_out: bool ^ WORDSIZE);
var c_addr, c_data, c_valid, next_addr: bool;
var state: int; -- 0: idle, 1: rd_miss, 2: rd_wait, 3: rd_upd, 4: wr, 5: wr_wait
let
  c_addr = 0->(if state = 3 then next_addr else pre_c_addr);
  c_valid = 0->(if state = 1 then false
                else if state = 3 then true
                     else pre c_valid);
  c_data = 0->(if state = 3 then b_out[DT]
               else if state = 4 and c_addr = ad then val
                    else pre c_data);
  gel = false->(if state = 0 or state = 3 or (state = 5 and b_out[VALID]) then false
                else if state = 1 or state = 2 or state = 4 or (state = 5 and not b_out[VALID]) then true
                     else pre gel);
  b_in = [0, 0, false, 0]->(if state = 0 then [ad, op, true, val]
                            else if state = 1 or state = 2 or state = 4 or state = 5 then pre b_in
                                 else [0, 0, false, 0]);
  b_req = false->(if state = 1 or state = 4 then true
                  else if state = 2 and state = 5 then pre b_req
                       else false);
  val_out = 0->(if state = 3 or (state = 0 and c_addr = ad and not op) then c_data
                else pre val_out);
  state = 0->(if state = 0 -- idle
              then if not op then -- idle read
                     if c_addr = ad then 0 -- idle read hit
                     else 1 -- idle read miss
                   else 4 -- idle write
              else if state = 1 -- rd_miss
                   then 2
                   else if state = 2 -- rd_wait
                        then if b_out[VALID] then 3 else 2
                        else if state = 3 -- rd_upd
                             then 0
                             else if state = 4 -- wr
                                  then 5
                                  else -- wr_wait
                                    if b_out[VALID]
                                    then 0
                                    else 5);
tel

node main () returns ();
let
  
tel